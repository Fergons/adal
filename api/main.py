# main.py
import os
import logging
from fastapi import FastAPI, HTTPException, status
from fastapi.concurrency import run_in_threadpool 
# Use run_in_threadpool to avoid blocking the event loop with synchronous model calls

# Import your schemas and embedder class
from schemas import EmbedRequest, EmbedResponse, EmbeddingOutput
from embedder import M3Embedder, EmbedderOutput as M3EmbedderOutput

# --- Configuration ---
# Use environment variables or a config file for flexibility
MODEL_NAME = os.getenv("MODEL_NAME", "BAAI/bge-m3")
DEVICE = os.getenv("DEVICE", "cuda:0") # Or "cpu"
BATCH_SIZE = int(os.getenv("BATCH_SIZE", "64"))
MAX_LENGTH = int(os.getenv("MAX_LENGTH", "8192")) # BGE M3 default max length
NORMALIZE_EMBEDDINGS = os.getenv("NORMALIZE_EMBEDDINGS", "True").lower() == 'true'

# --- Logging Setup ---
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# --- FastAPI App Initialization ---
app = FastAPI(
    title="BGE M3 Embedding Service",
    description="API to generate embeddings using the BAAI/bge-m3 model.",
    version="1.0.0"
)

# --- Global Embedder Instance ---
# Load the model only once when the application starts
try:
    logger.info("Loading BGE M3 Embedder...")
    embedder = M3Embedder(
        model_name=MODEL_NAME, 
        device=DEVICE, 
        batch_size=BATCH_SIZE, 
        max_length=MAX_LENGTH,
        normalize_embeddings=NORMALIZE_EMBEDDINGS
    )
    logger.info("Embedder loaded successfully.")
except Exception as e:
    logger.exception("Failed to load the embedder model during startup!")
    # Optionally raise an error to prevent startup if the model fails to load
    raise RuntimeError(f"Could not initialize M3Embedder: {e}") from e


# --- API Endpoints ---
@app.get("/health", status_code=status.HTTP_200_OK)
async def health_check():
    """Basic health check endpoint."""
    return {"status": "healthy"}

@app.post("/embed/", 
          response_model=EmbedResponse,
          summary="Generate Embeddings",
          description="Takes a string or list of strings and returns their dense embeddings generated by BGE M3.")
async def create_embeddings(request: EmbedRequest):
    """
    Generates dense vector embeddings for the input text(s).
    
    - **texts**: A single string or a list of strings to embed.
    """
    if not request.texts:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, 
                            detail="Input 'texts' cannot be empty.")

    try:
        # Run the synchronous embedder call in a thread pool
        # This prevents blocking the main FastAPI event loop
        m3_output: M3EmbedderOutput = await run_in_threadpool(embedder, request.texts)

        if m3_output.error:
             # If the embedder's __call__ method caught an error and returned it
             logger.error(f"Embedding failed internally: {m3_output.error}")
             raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, 
                                 detail=f"Embedding failed: {m3_output.error}")

        # Convert the internal Embedding objects to Pydantic EmbeddingOutput models
        response_data = [
            EmbeddingOutput(embedding=emb.embedding, index=emb.index) 
            for emb in m3_output.data
        ]
        
        input_count = len(request.texts) if isinstance(request.texts, list) else 1

        return EmbedResponse(
            data=response_data, 
            model=m3_output.model,
            input_texts_count=input_count
            # raw_response=m3_output.raw_response # Optional
        )

    except HTTPException:
        # Re-raise known HTTP exceptions
        raise
    except Exception as e:
        # Catch any unexpected errors during the process
        logger.exception(f"Unexpected error during embedding request: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, 
                            detail=f"An unexpected error occurred: {str(e)}")


if __name__ == "__main__":
    import uvicorn
    PORT = int(os.getenv("PORT", "8000"))
    HOST = os.getenv("HOST", "0.0.0.0")
    uvicorn.run(app, host=HOST, port=PORT)